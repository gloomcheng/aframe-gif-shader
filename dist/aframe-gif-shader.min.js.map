{"version":3,"file":"aframe-gif-shader.min.js","mappings":"yBAOAA,EAAQ,EAAW,SAAUC,EAAKC,EAAWC,GAE3C,IAAIC,EAAM,EACNC,EAAa,GACbC,EAAU,EACVC,EAAiB,KACjBC,EAAY,KACZC,EAAS,GACTC,EAAU,EACd,GAAe,KAAXT,EAAI,IAA0B,KAAXA,EAAI,IAA0B,KAAXA,EAAI,IACjC,KAAXA,EAAI,IAA2B,KAAXA,EAAI,IAA0B,KAAXA,EAAI,IAA2B,KAAXA,EAAI,GA8BxDE,GAAWA,EAAQ,2BA9BkD,CAC5EC,GAAO,QAAoB,IAAVH,EAAI,KAAcU,KAAKC,IAAI,EAAsB,GAAR,EAAVX,EAAI,MAAmB,EAEvE,IADA,IAAIY,EAAYZ,EAAIa,SAAS,EAAGV,GACzBH,EAAIG,IAAqB,KAAbH,EAAIG,IAAe,CACpC,IAAIW,EAASX,EAAKY,EAAUf,EAAIG,GAChC,GAAgB,KAAZY,EAAkB,CACpB,IAAIC,EAAQhB,IAAMG,GAClB,IAAiD,IAA7C,CAAC,EAAM,IAAM,IAAM,KAAMc,QAAQD,GAK9B,CAAEd,GAAWA,EAAQ,2BAA4B,KAAO,CAF7D,IAFU,MAAVc,GAAmBZ,EAAWc,KAA4C,IAAtClB,EAAIG,EAAM,IAAMH,EAAIG,EAAM,IAAM,KAC1D,MAAVa,IAAmBP,EAAUT,EAAIG,EAAM,KAAOH,EAAIG,EAAM,KAAO,IACxDH,IAAMG,IAAMA,GAAOH,EAAIG,GACpB,MAAVa,IAAmBV,EAAiBN,EAAIa,SAASC,EAAQX,EAAM,GAEnE,KAAO,IAAgB,KAAZY,EAcJ,CAAEb,GAAWA,EAAQ,6BAA8B,KAAO,CAX/D,IAFAC,GAAO,EACPA,GAAO,OAAoB,IAAXH,EAAIG,KAAqD,EAArCO,KAAKC,IAAI,EAAuB,GAAR,EAAXX,EAAIG,MAC9CH,IAAMG,IAAMA,GAAOH,EAAIG,GAC1BI,EAAYP,EAAIa,SAASC,EAAQX,EAAM,GAA3C,IAEIgB,EAAQ,CAIVC,eAAgBd,EAAe,GAC/Be,KAAKC,IAAIC,gBAAgB,IAAIC,KAAK,CAACZ,EAAWN,EAAgBC,MAEhEC,EAAOU,KAAKC,EACmD,CACjEhB,GACF,CACF,CACA,GAAIK,EAAOiB,OAAQ,CAEjB,IAAIC,EAAMC,SAASC,cAAc,UAqB7BC,EAAW,SAAUC,GACvB,IAAIC,EAAM,IAAIC,MACdD,EAAIE,OAAS,SAAUC,EAAGJ,GACxBzB,IACAG,EAAOsB,GAAKK,KACR9B,IAAYG,EAAOiB,QACrBC,EAAM,KACNzB,GAAaA,EAAUG,EAAYK,EAASD,IAE5CqB,IAAWC,EAEf,EAAEM,KAAKL,GACPA,EAAIM,IAAMX,EAAIY,UAAU,YAC1B,GAjCc,WACZ,IAAI,IAAIR,EAAI,EAAGA,EAAItB,EAAOiB,OAAQK,IAAI,CACpC,IAAIC,EAAM,IAAIC,MACdD,EAAIE,OAAS,SAAUC,EAAGJ,GACd,IAANA,IACFJ,EAAIa,MAAQR,EAAIQ,MAChBb,EAAIc,OAAST,EAAIS,QAEnBnC,IACAG,EAAOsB,GAAKK,KACR9B,IAAYG,EAAOiB,SACrBpB,EAAU,EACVwB,EAAS,GAEb,EAAEO,KAAKL,EAAK,KAAMD,GAElBC,EAAIM,IAAM7B,EAAOsB,GAAGT,KACpBU,EAAIX,eAAiBZ,EAAOsB,GAAGV,cACjC,CACF,CAeAqB,EACF,CACF,C,GCtFIC,EAA2B,CAAC,EAGhC,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqBE,IAAjBD,EACH,OAAOA,EAAa9C,QAGrB,IAAIgD,EAASL,EAAyBE,GAAY,CAGjD7C,QAAS,CAAC,GAOX,OAHAiD,EAAoBJ,GAAUG,EAAQA,EAAOhD,QAAS4C,GAG/CI,EAAOhD,OACf,C,gCCpBA,GAAsB,oBAAXkD,OACT,KAAM,+DAIR,MAAM,SAAEC,GAAaD,OAAOE,MAAMC,WAC5B,MAAEC,GAAUJ,OAAOE,MAEzBE,EAAMC,OAAO,mBACb,MAAMC,EAAOF,EAAM,mBACbG,EAAMH,EAAM,oBAGZI,EAAU,CAAC,EAGjB,SAASC,EAAYC,EAAKtB,GACxB,MAAO,CAAEuB,OAAQ,QAASvB,IAAKA,EAAKwB,QAASF,EAAKG,UAAWC,KAAKC,MACpE,CAEAf,OAAOgB,eAAe,MAAO,CAS3BC,OAAQ,CAENC,MAAO,CAAEC,KAAM,SACfC,IAAK,CAAEC,SAAS,GAGhBjC,IAAK,CAAE+B,KAAM,SAAUE,QAAS,IAChCC,SAAU,CAAED,SAAS,IAOvB,IAAAE,CAAKC,GA4BH,OA3BAjB,EAAI,OAAQiB,GACZjB,EAAIrB,KAAKuC,GAAGC,YACZxC,KAAKyC,MAAQjD,SAASC,cAAc,UACpCO,KAAKyC,MAAMrC,MAAQ,EACnBJ,KAAKyC,MAAMpC,OAAS,EACpBL,KAAK0C,MAAQ1C,KAAKyC,MAAME,WAAW,KAAM,CACvCC,oBAAoB,IAEtB5C,KAAK6C,UAAY,IAAIC,MAAMC,QAAQ/C,KAAKyC,OACxCzC,KAAK6C,UAAUG,UAAYF,MAAMG,aACjCjD,KAAK6C,UAAUK,UAAYJ,MAAMG,aACjCjD,KAAK6C,UAAUM,iBAAkB,EACjCnD,KAAK6C,UAAUO,WAAaN,MAAMO,eAClCrD,KAAK6C,UAAUS,kBAAmB,EAC9BhB,EAAKiB,SACPvD,KAAK6C,UAAUW,MAAQV,MAAMW,eAC7BzD,KAAK6C,UAAUa,MAAQZ,MAAMW,eAC7BzD,KAAK6C,UAAUU,OAAOI,IAAIrB,EAAKiB,OAAOK,EAAGtB,EAAKiB,OAAOM,IAEvD7D,KAAK8D,WAAa,CAAC,EACnB9D,KAAK+D,UACL/D,KAAKgE,SAAW,IAAIlB,MAAMmB,kBAAkB,CAC1CC,IAAKlE,KAAK6C,UACVsB,aAAa,EACbC,oBAAoB,IAEtBpE,KAAKuC,GAAG8B,QAAQC,YAAYtE,MACrBA,KAAKgE,QACd,EAMA,MAAAO,CAAOC,GAIL,OAHAnD,EAAI,SAAUmD,GACdxE,KAAKyE,iBAAiBD,GACtBxE,KAAK0E,gBAAgBF,GACdxE,KAAKgE,QACd,EAMA,IAAAW,CAAKC,GACE5E,KAAK6E,WAAY7E,KAAK8E,UACvBlD,KAAKC,MAAQ7B,KAAK+E,aAAe/E,KAAKgF,iBACxChF,KAAKiF,WAET,EAUA,gBAAAR,CAAiBnC,GACf,MAAM,SAAE0B,GAAahE,KACfkF,EAAUlF,KAAKmF,kBAAkB7C,GACvC8C,OAAOC,KAAKH,GAASI,SAASC,IAC5BvB,EAASuB,GAAOL,EAAQK,EAAI,GAEhC,EAOAJ,kBAAkB7C,IACT,CACLJ,IAAKI,EAAKJ,IACVF,MAAO,IAAIc,MAAM0C,MAAMlD,EAAKN,SAoBhC,WAAAyD,CAAYnD,GACVjB,EAAI,cAAeiB,GACC,UAAhBA,EAAKb,QACPL,EAAK,UAAUkB,EAAKZ,iBAAiBY,EAAKpC,OAC1CF,KAAK+D,WACoB,YAAhBzB,EAAKb,QAAwBa,EAAKpC,MAAQF,KAAK0F,eACxD1F,KAAK+D,UAEL/D,KAAK2F,QAAQrD,GAEjB,EAMA,eAAAoC,CAAgBpC,GACd,MAAM,IAAEpC,EAAG,SAAEkC,GAAaE,EAGF,kBAAbF,EACTpC,KAAK4F,WAAaxD,OACW,IAAbA,IAChBpC,KAAK4F,YAAa,GAEhB5F,KAAK4F,YAAc5F,KAAK6E,UAC1B7E,KAAK6F,OAIH3F,EACFF,KAAK8F,cAAc5F,EAAKF,KAAKyF,YAAYxF,KAAKD,OAG9CA,KAAK+D,SAET,EAMA,aAAA+B,CAAc5F,EAAK6F,GACjB,GAAK7F,EAML,GAAIA,EAAI8F,WAAW,KAAM,CACvB,MAAMzD,EAAKvC,KAAKiG,8BAA8B/F,GAC9C,IAAKqC,GAAoB,iBAAPA,EAEhB,YADAnB,EAAK,yCAAyClB,KAGhD,GAAIqC,EAAG2D,MACL9E,EAAK,UAAUmB,EAAG2D,eAAehG,KACjC6F,EAAGxE,EAAYgB,EAAG2D,MAAOhG,QACpB,CACL,MAAMiG,EAAU5D,EAAG4D,QAAQC,cAC3B,GAAgB,QAAZD,EAEG5D,EAAG8D,SAKNrG,KAAKsG,cAAc/D,EAAGrC,IAAK6F,GAJ3BxD,EAAGgE,iBAAiB,QAAQ,KAC1BvG,KAAKsG,cAAc/D,EAAGrC,IAAK6F,EAAG,QAK7B,CACL,MAAMrE,EAAU,QAAQyE,gDACxB/E,EAAK,UAAUM,WAAiBxB,KAChC6F,EAAGxE,EAAYG,EAASxB,GAC1B,CACF,CACF,KAAO,CAEL,MAAMsG,EAAUxG,KAAKuC,GAAG8B,QAAQoC,QAC1BC,EAAc,IAAIvH,IAAIe,EAAKsG,GAASG,KAC1C3G,KAAKsG,cAAcI,EAAaX,EAClC,MApCE3E,EAAK,sBAqCT,EAOA,aAAAkF,CAAcpG,EAAK6F,GAEjB,GAAI7F,IAAQF,KAAK0F,aACf,OAIF,IAAIkB,EAAUtF,EAAQpB,GACtB,GAAK0G,GAAYA,EAAQC,UAIlB,IAAID,EAAQ1G,IAEjB,YADA6F,EAAGa,GAEE,GAAIA,EAAQC,UAGjB,YADAD,EAAQC,UAAU9H,KAAKgH,EAEzB,MATEa,EAAUtF,EAAQpB,GAAO,CAAE2G,UAAW,IACtCD,EAAQC,UAAU9H,KAAKgH,GASzB,MAAMe,EAAS,IAAIjH,MAsCnB,SAASkH,EAAQrF,GAEf,MAAMsF,EAAUzF,EAAYG,EAASxB,GAEjC0G,EAAQC,YACVD,EAAQC,UAAUvB,SAASS,GAAOA,EAAGiB,KAErC1F,EAAQpB,GAAO8G,EAEnB,CA9CAF,EAAOG,YAAc,YACrBH,EAAOP,iBAAiB,QAASxG,IAE/BC,KAAKkH,gBAAgBhH,GAAMiH,IACpBA,GAKL,OACEA,GACA,CAACC,EAAOC,EAAKhJ,KAEX,MAAM6G,EAAU,CACdzD,OAAQ,UACRvB,IAAKA,EACLkH,MAAOA,EACPC,IAAKA,EACLhJ,OAAQA,EACRsD,UAAWC,KAAKC,OAGd+E,EAAQC,YACVD,EAAQC,UAAUvB,SAASS,GAAOA,EAAGb,KAErC5D,EAAQpB,GAAOgF,EACjB,IAED1D,GAAQuF,EAAQvF,KAvBjBuF,EAAQ,oDAwBT,GACD,IAEJD,EAAOP,iBAAiB,SAAUxG,GAChCgH,EACE,sGAaJD,EAAO5G,IAAMA,CACf,EAOA,eAAAgH,CAAgBhH,EAAK6F,GACnB,GAAkB,mBAAPA,EACT,OAGF,MAAMuB,EAAM,IAAIC,eAChBD,EAAIE,KAAK,MAAOtH,GAChBoH,EAAIG,aAAe,cACnBH,EAAIf,iBAAiB,QAASxG,IAC5B,MAAM2H,EAAa,IAAIC,WAAW5H,EAAE6H,OAAOC,UACrCV,EAAMO,EAAWhJ,SAAS,EAAG,GAEnC,IAAIoJ,EAAS,GACb,IAAK,IAAInI,EAAI,EAAGA,EAAIwH,EAAI7H,OAAQK,IAC9BmI,GAAUX,EAAIxH,GAAGoI,SAAS,IAEb,aAAXD,EACF/B,EAAG2B,GAEH3B,GACF,IAEFuB,EAAIf,iBAAiB,SAAUxG,IAC7BsB,EAAItB,GACJgG,GAAI,IAENuB,EAAIU,MACN,EAQA,6BAAA/B,CAA8BgC,GAC5B,IAEE,OADSzI,SAAS0I,cAAcD,IAEvB,CAAE/B,MAAO,6CAGpB,CAAE,MAAOnG,GAEP,MAAO,CAAEmG,MAAO,oBAClB,CACF,EAUA,KAAAiC,GACE9G,EAAI,SACJrB,KAAKoI,UAAW,CAClB,EAMA,IAAAvC,GACExE,EAAI,QACJrB,KAAKoI,UAAW,CAClB,EAOA,cAAAC,GACMrI,KAAK8E,SACP9E,KAAK6F,OAEL7F,KAAKmI,OAET,EAOA,MAAArD,GACE,OAAO9E,KAAKoI,QACd,EAMA,SAAAnD,GAIE,IAHAjF,KAAKsI,SAGE1G,KAAKC,MAAQ7B,KAAK+E,aAAe/E,KAAKgF,iBAC3ChF,KAAKgF,iBAAmBhF,KAAKuI,aAAavI,KAAKwI,eAE5CxI,KAAKyI,YAAczI,KAAK0I,YACzB1I,KAAK2I,YAAc3I,KAAKwI,aAGxBxI,KAAKwI,WAAa,EAGxB,EAUA,aAAAI,GACE5I,KAAK0C,MAAMmG,UAAU,EAAG,EAAG7I,KAAK8I,QAAS9I,KAAK+I,UAC9C/I,KAAK6C,UAAUmG,aAAc,CAC/B,EAMA,MAAAV,GACE,GAAuB,GAAnBtI,KAAKwI,WAAiB,CACxB,MAAMS,EAAYjJ,KAAK6E,SAAS7E,KAAKwI,WAAa,GAClB,GAA5BS,EAAUhK,gBAAmD,GAA5BgK,EAAUhK,gBAC7Ce,KAAK4I,eAET,MACE5I,KAAK4I,gBAEP,MAAMM,EAAclJ,KAAK6E,SAAS7E,KAAKwI,YACvC,QAA2B,IAAhBU,EAA6B,CAEtClJ,KAAK4I,gBAGL,MAAMO,EAAQ5K,KAAK6K,IACjBpJ,KAAK8I,QAAUI,EAAY9I,MAC3BJ,KAAK+I,SAAWG,EAAY7I,QAGxBgJ,EAAcH,EAAY9I,MAAQ+I,EAClCG,EAAeJ,EAAY7I,OAAS8I,EAGpCvF,GAAK5D,KAAK8I,QAAUO,GAAe,EACnCxF,GAAK7D,KAAK+I,SAAWO,GAAgB,EAG3CtJ,KAAK0C,MAAM6G,UACTL,EACA,EAAG,EAAGA,EAAY9I,MAAO8I,EAAY7I,OACrCuD,EAAGC,EAAGwF,EAAaC,GAGrBtJ,KAAK6C,UAAUmG,aAAc,CAC/B,CACF,EAcA,OAAArD,EAAQ,IAAEzF,EAAG,MAAEkH,EAAK,IAAEC,EAAG,OAAEhJ,IACzBgD,EAAI,WACJrB,KAAK0F,aAAexF,EACpBF,KAAKuI,aAAenB,EACpBC,EAAOrH,KAAK0I,UAAYrB,EAAQrH,KAAKyI,YAAa,EAClDzI,KAAK6E,SAAWxG,EAChB2B,KAAK2I,WAAavB,EAAM9H,OACxBU,KAAK+E,YAAcnD,KAAKC,MAGxB,MAIM2H,EAAU,KAChB,IAAIpJ,EALkB/B,EAAO,GAAG+B,MAM5BC,EALmBhC,EAAO,GAAGgC,OAOjC,GAAID,EAAQoJ,GAAWnJ,EAASmJ,EAAS,CACvC,MAAMC,EAAQlL,KAAK6K,IAAII,EAAUpJ,EAAOoJ,EAAUnJ,GAClDD,EAAQ7B,KAAKmL,MAAMtJ,EAAQqJ,GAC3BpJ,EAAS9B,KAAKmL,MAAMrJ,EAASoJ,EAC/B,CAGAzJ,KAAK8I,QAAU1I,EACfJ,KAAK+I,SAAW1I,EAChBL,KAAKyC,MAAMrC,MAAQA,EACnBJ,KAAKyC,MAAMpC,OAASA,EAGpBL,KAAK6C,UAAU8G,iBAAkB,EACjC3J,KAAK6C,UAAUG,UAAYF,MAAMG,aACjCjD,KAAK6C,UAAUK,UAAYJ,MAAMG,aACjCjD,KAAK6C,UAAUM,iBAAkB,EACjCnD,KAAK6C,UAAUO,WAAaN,MAAMO,eAClCrD,KAAK6C,UAAUS,kBAAmB,EAGlCtD,KAAK6C,UAAUU,OAAOI,IAAI,EAAG,GAC7B3D,KAAK6C,UAAUlE,OAAOgF,IAAI,EAAG,GAE7B3D,KAAKsI,SACDtI,KAAK4F,WACP5F,KAAK6F,OAEL7F,KAAKmI,OAET,EAQA,OAAApE,GACE/D,KAAKmI,QACLnI,KAAK4I,gBACL5I,KAAK+E,YAAc,EACnB/E,KAAKgF,gBAAkB,EACvBhF,KAAKwI,WAAa,EAClBxI,KAAK2I,WAAa,EAClB3I,KAAKuI,aAAe,KACpBvI,KAAKyI,YAAa,EAClBzI,KAAK0I,UAAY,EACjB1I,KAAK6E,SAAW,KAChB7E,KAAK0F,aAAe,IACtB,G","sources":["webpack://aframe-gif-shader/./lib/gifsparser.js","webpack://aframe-gif-shader/webpack/bootstrap","webpack://aframe-gif-shader/./index.js"],"sourcesContent":["/**\n * \n * Gif parser by @gtk2k\n * https://github.com/gtk2k/gtk2k.github.io/tree/master/animation_gif\n *\n */\n\nexports.parseGIF = function (gif, successCB, errorCB) {\n\n  var pos = 0;\n  var delayTimes = [];\n  var loadCnt = 0;\n  var graphicControl = null;\n  var imageData = null;\n  var frames = [];\n  var loopCnt = 0;\n  if (gif[0] === 0x47 && gif[1] === 0x49 && gif[2] === 0x46 && // 'GIF'\n    gif[3] === 0x38 && (gif[4] === 0x39 || gif[4] === 0x37) && gif[5] === 0x61) { // '89a'\n    pos += 13 + (+!!(gif[10] & 0x80) * Math.pow(2, (gif[10] & 0x07) + 1) * 3);\n    var gifHeader = gif.subarray(0, pos);\n    while (gif[pos] && gif[pos] !== 0x3b) {\n      var offset = pos, blockId = gif[pos];\n      if (blockId === 0x21) {\n        var label = gif[++pos];\n        if ([0x01, 0xfe, 0xf9, 0xff].indexOf(label) !== -1) {\n          label === 0xf9 && (delayTimes.push((gif[pos + 3] + (gif[pos + 4] << 8)) * 10));\n          label === 0xff && (loopCnt = gif[pos + 15] + (gif[pos + 16] << 8));\n          while (gif[++pos]) pos += gif[pos];\n          label === 0xf9 && (graphicControl = gif.subarray(offset, pos + 1));\n        } else { errorCB && errorCB('parseGIF: unknown label'); break; }\n      } else if (blockId === 0x2c) {\n        pos += 9;\n        pos += 1 + (+!!(gif[pos] & 0x80) * (Math.pow(2, (gif[pos] & 0x07) + 1) * 3));\n        while (gif[++pos]) pos += gif[pos];\n        var imageData = gif.subarray(offset, pos + 1);\n        // Each frame should have an image and a flag to indicate how to dispose it.\n        var frame = {\n          // http://matthewflickinger.com/lab/whatsinagif/animation_and_transparency.asp\n          // Disposal method is a flag stored in the 3rd byte of the graphics control\n          // This byte is packed and stores more information, only 3 bits of it represent the disposal\n          disposalMethod: graphicControl[3],\n          blob:URL.createObjectURL(new Blob([gifHeader, graphicControl, imageData]))\n        }\n        frames.push(frame);\n      } else { errorCB && errorCB('parseGIF: unknown blockId'); break; }\n      pos++;\n    }\n  } else { errorCB && errorCB('parseGIF: no GIF89a'); }\n  if (frames.length) {\n\n    var cnv = document.createElement('canvas');      \n    var loadImg = function () {\n      for(var i = 0; i < frames.length; i++){\n        var img = new Image();\n        img.onload = function (e, i) {\n          if (i === 0) {\n            cnv.width = img.width\n            cnv.height = img.height\n          }\n          loadCnt++;\n          frames[i] = this;\n          if (loadCnt === frames.length) {\n            loadCnt = 0;\n            imageFix(1);\n          }\n        }.bind(img, null, i);\n        // Link html image tag with the extracted GIF Frame \n        img.src = frames[i].blob;\n        img.disposalMethod = frames[i].disposalMethod;\n      }\n    }\n    var imageFix = function (i) {\n      var img = new Image();\n      img.onload = function (e, i) {\n        loadCnt++;\n        frames[i] = this;\n        if (loadCnt === frames.length) {\n          cnv = null;\n          successCB && successCB(delayTimes, loopCnt, frames);\n        } else {\n          imageFix(++i);\n        }\n      }.bind(img);\n      img.src = cnv.toDataURL('image/gif');\n    }\n    loadImg();\n  }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import { parseGIF } from \"./lib/gifsparser\";\n\nif (typeof AFRAME === \"undefined\") {\n  throw \"Component attempted to register before AFRAME was available.\";\n}\n\n/* get util from AFRAME */\nconst { parseUrl } = AFRAME.utils.srcLoader;\nconst { debug } = AFRAME.utils;\n// debug.enable('shader:gif:*')\ndebug.enable(\"shader:gif:warn\");\nconst warn = debug(\"shader:gif:warn\");\nconst log = debug(\"shader:gif:debug\");\n\n/* store data so that you won't load same data */\nconst gifData = {};\n\n/* create error message */\nfunction createError(err, src) {\n  return { status: \"error\", src: src, message: err, timestamp: Date.now() };\n}\n\nAFRAME.registerShader(\"gif\", {\n  /**\n   * For material component:\n   * @see https://github.com/aframevr/aframe/blob/60d198ef8e2bfbc57a13511ae5fca7b62e01691b/src/components/material.js\n   * For example of `registerShader`:\n   * @see https://github.com/aframevr/aframe/blob/41a50cd5ac65e462120ecc2e5091f5daefe3bd1e/src/shaders/flat.js\n   * For MeshBasicMaterial\n   * @see http://threejs.org/docs/#Reference/Materials/MeshBasicMaterial\n   */\n  schema: {\n    /* For material */\n    color: { type: \"color\" },\n    fog: { default: true },\n\n    /* For texuture */\n    src: { type: \"string\", default: \"\" },\n    autoplay: { default: true },\n  },\n\n  /**\n   * Initialize material. Called once.\n   * @protected\n   */\n  init(data) {\n    log(\"init\", data);\n    log(this.el.components);\n    this.__cnv = document.createElement(\"canvas\");\n    this.__cnv.width = 2;\n    this.__cnv.height = 2;\n    this.__ctx = this.__cnv.getContext(\"2d\", {\n      willReadFrequently: true\n    });\n    this.__texture = new THREE.Texture(this.__cnv); //renders straight from a canvas\n    this.__texture.minFilter = THREE.LinearFilter;\n    this.__texture.magFilter = THREE.LinearFilter;\n    this.__texture.generateMipmaps = false;\n    this.__texture.colorSpace = THREE.SRGBColorSpace;\n    this.__texture.premultiplyAlpha = true;\n    if (data.repeat) {\n      this.__texture.wrapS = THREE.RepeatWrapping;\n      this.__texture.wrapT = THREE.RepeatWrapping;\n      this.__texture.repeat.set(data.repeat.x, data.repeat.y);\n    }\n    this.__material = {};\n    this.__reset();\n    this.material = new THREE.MeshBasicMaterial({ \n      map: this.__texture,\n      transparent: true,\n      premultipliedAlpha: true\n    });\n    this.el.sceneEl.addBehavior(this);\n    return this.material;\n  },\n\n  /**\n   * Update or create material.\n   * @param {object|null} oldData\n   */\n  update(oldData) {\n    log(\"update\", oldData);\n    this.__updateMaterial(oldData);\n    this.__updateTexture(oldData);\n    return this.material;\n  },\n\n  /**\n   * Called on each scene tick.\n   * @protected\n   */\n  tick(t) {\n    if (!this.__frames || this.paused()) return;\n    if (Date.now() - this.__startTime >= this.__nextFrameTime) {\n      this.nextFrame();\n    }\n  },\n\n  /*================================\n  =            material            =\n  ================================*/\n\n  /**\n   * Updating existing material.\n   * @param {object} data - Material component data.\n   */\n  __updateMaterial(data) {\n    const { material } = this;\n    const newData = this.__getMaterialData(data);\n    Object.keys(newData).forEach((key) => {\n      material[key] = newData[key];\n    });\n  },\n\n  /**\n   * Builds and normalize material data, normalizing stuff along the way.\n   * @param {Object} data - Material data.\n   * @return {Object} data - Processed material data.\n   */\n  __getMaterialData(data) {\n    return {\n      fog: data.fog,\n      color: new THREE.Color(data.color),\n    };\n  },\n\n  /*==============================\n  =            texure            =\n  ==============================*/\n\n  /**\n   * set texure\n   * @private\n   * @param {Object} data\n   * @property {string} status - success / error\n   * @property {string} src - src url\n   * @property {array} times - array of time length of each image\n   * @property {number} cnt - total counts of gif images\n   * @property {array} frames - array of each image\n   * @property {Date} timestamp - created at the texure\n   */\n\n  __setTexure(data) {\n    log(\"__setTexure\", data);\n    if (data.status === \"error\") {\n      warn(`Error: ${data.message}\\nsrc: ${data.src}`);\n      this.__reset();\n    } else if (data.status === \"success\" && data.src !== this.__textureSrc) {\n      this.__reset();\n      /* Texture added or changed */\n      this.__ready(data);\n    }\n  },\n\n  /**\n   * Update or create texure.\n   * @param {Object} data - Material component data.\n   */\n  __updateTexture(data) {\n    const { src, autoplay } = data;\n\n    /* autoplay */\n    if (typeof autoplay === \"boolean\") {\n      this.__autoplay = autoplay;\n    } else if (typeof autoplay === \"undefined\") {\n      this.__autoplay = true;\n    }\n    if (this.__autoplay && this.__frames) {\n      this.play();\n    }\n\n    /* src */\n    if (src) {\n      this.__validateSrc(src, this.__setTexure.bind(this));\n    } else {\n      /* Texture removed */\n      this.__reset();\n    }\n  },\n\n  /*=============================================\n  =            varidation for texure            =\n  =============================================*/\n\n  __validateSrc(src, cb) {\n    if (!src) {\n      warn('src is not provided');\n      return;\n    }\n\n    /* check if src starts with # for asset items */\n    if (src.startsWith('#')) {\n      const el = this.__validateAndGetQuerySelector(src);\n      if (!el || typeof el !== \"object\") {\n        warn(`Could not find element with selector: ${src}`);\n        return;\n      }\n      if (el.error) {\n        warn(`Error: ${el.error}\\nsrc: ${src}`);\n        cb(createError(el.error, src));\n      } else {\n        const tagName = el.tagName.toLowerCase();\n        if (tagName === \"img\") {\n          // Wait for the asset to load\n          if (!el.complete) {\n            el.addEventListener('load', () => {\n              this.__getImageSrc(el.src, cb);\n            });\n          } else {\n            this.__getImageSrc(el.src, cb);\n          }\n        } else {\n          const message = `For <${tagName}> element, please use \\`aframe-html-shader\\``;\n          warn(`Error: ${message}\\nsrc: ${src}`);\n          cb(createError(message, src));\n        }\n      }\n    } else {\n      /* treat as direct file path */\n      const baseUrl = this.el.sceneEl.baseURI;\n      const resolvedUrl = new URL(src, baseUrl).href;\n      this.__getImageSrc(resolvedUrl, cb);\n    }\n  },\n\n  /**\n   * Validate src is a valid image url\n   * @param  {string} src - url that will be tested\n   * @param  {function} cb - callback with the test result\n   */\n  __getImageSrc(src, cb) {\n    /* if src is same as previous, ignore this */\n    if (src === this.__textureSrc) {\n      return;\n    }\n\n    /* check if we already get the srcData */\n    let srcData = gifData[src];\n    if (!srcData || !srcData.callbacks) {\n      /* create callback */\n      srcData = gifData[src] = { callbacks: [] };\n      srcData.callbacks.push(cb);\n    } else if (srcData.src) {\n      cb(srcData);\n      return;\n    } else if (srcData.callbacks) {\n      /* add callback */\n      srcData.callbacks.push(cb);\n      return;\n    }\n    const tester = new Image();\n    tester.crossOrigin = \"Anonymous\";\n    tester.addEventListener(\"load\", (e) => {\n      /* check if it is gif */\n      this.__getUnit8Array(src, (arr) => {\n        if (!arr) {\n          onError(\"This is not gif. Please use `shader:flat` instead\");\n          return;\n        }\n        /* parse data */\n        parseGIF(\n          arr,\n          (times, cnt, frames) => {\n            /* store data */\n            const newData = {\n              status: \"success\",\n              src: src,\n              times: times,\n              cnt: cnt,\n              frames: frames,\n              timestamp: Date.now(),\n            };\n            /* callbacks */\n            if (srcData.callbacks) {\n              srcData.callbacks.forEach((cb) => cb(newData));\n              /* overwrite */\n              gifData[src] = newData;\n            }\n          },\n          (err) => onError(err)\n        );\n      });\n    });\n    tester.addEventListener(\"error\", (e) =>\n      onError(\n        \"Could be the following issue\\n - Not Image\\n - Not Found\\n - Server Error\\n - Cross-Origin Issue\"\n      )\n    );\n    function onError(message) {\n      /* create error data */\n      const errData = createError(message, src);\n      /* callbacks */\n      if (srcData.callbacks) {\n        srcData.callbacks.forEach((cb) => cb(errData));\n        /* overwrite */\n        gifData[src] = errData;\n      }\n    }\n    tester.src = src;\n  },\n\n  /**\n   *\n   * get mine type\n   *\n   */\n  __getUnit8Array(src, cb) {\n    if (typeof cb !== \"function\") {\n      return;\n    }\n\n    const xhr = new XMLHttpRequest();\n    xhr.open(\"GET\", src);\n    xhr.responseType = \"arraybuffer\";\n    xhr.addEventListener(\"load\", (e) => {\n      const uint8Array = new Uint8Array(e.target.response);\n      const arr = uint8Array.subarray(0, 4);\n      // const header = arr.map(value => value.toString(16)).join('')\n      let header = \"\";\n      for (let i = 0; i < arr.length; i++) {\n        header += arr[i].toString(16);\n      }\n      if (header === \"47494638\") {\n        cb(uint8Array);\n      } else {\n        cb();\n      }\n    });\n    xhr.addEventListener(\"error\", (e) => {\n      log(e);\n      cb();\n    });\n    xhr.send();\n  },\n\n  /**\n   * Query and validate a query selector,\n   *\n   * @param  {string} selector - DOM selector.\n   * @return {object} Selected DOM element | error message object.\n   */\n  __validateAndGetQuerySelector(selector) {\n    try {\n      var el = document.querySelector(selector);\n      if (!el) {\n        return { error: \"No element was found matching the selector\" };\n      }\n      return el;\n    } catch (e) {\n      // Capture exception if it's not a valid selector.\n      return { error: \"no valid selector\" };\n    }\n  },\n\n  /*================================\n  =            playback            =\n  ================================*/\n\n  /**\n   * Pause gif\n   * @public\n   */\n  pause() {\n    log(\"pause\");\n    this.__paused = true;\n  },\n\n  /**\n   * Play gif\n   * @public\n   */\n  play() {\n    log(\"play\");\n    this.__paused = false;\n  },\n\n  /**\n   * Toggle playback. play if paused and pause if played.\n   * @public\n   */\n\n  togglePlayback() {\n    if (this.paused()) {\n      this.play();\n    } else {\n      this.pause();\n    }\n  },\n\n  /**\n   * Return if the playback is paused.\n   * @public\n   * @return {boolean}\n   */\n  paused() {\n    return this.__paused;\n  },\n\n  /**\n   * Go to next frame\n   * @public\n   */\n  nextFrame() {\n    this.__draw();\n\n    /* update next frame time */\n    while (Date.now() - this.__startTime >= this.__nextFrameTime) {\n      this.__nextFrameTime += this.__delayTimes[this.__frameIdx++];\n      if (\n        (this.__infinity || this.__loopCnt) &&\n        this.__frameCnt <= this.__frameIdx\n      ) {\n        /* go back to the first */\n        this.__frameIdx = 0;\n      }\n    }\n  },\n\n  /*==============================\n   =            canvas            =\n   ==============================*/\n\n  /**\n   * clear canvas\n   * @private\n   */\n  __clearCanvas() {\n    this.__ctx.clearRect(0, 0, this.__width, this.__height);\n    this.__texture.needsUpdate = true;\n  },\n\n  /**\n   * draw\n   * @private\n   */\n  __draw() {\n    if (this.__frameIdx != 0) {\n      const lastFrame = this.__frames[this.__frameIdx - 1];\n      if (lastFrame.disposalMethod == 8 || lastFrame.disposalMethod == 9) {\n        this.__clearCanvas();\n      }\n    } else {\n      this.__clearCanvas();\n    }\n    const actualFrame = this.__frames[this.__frameIdx];\n    if (typeof actualFrame !== \"undefined\") {\n      // Clear the canvas first\n      this.__clearCanvas();\n      \n      // Calculate the scaling to maintain aspect ratio\n      const scale = Math.min(\n        this.__width / actualFrame.width,\n        this.__height / actualFrame.height\n      );\n      \n      const scaledWidth = actualFrame.width * scale;\n      const scaledHeight = actualFrame.height * scale;\n      \n      // Calculate position to center the image\n      const x = (this.__width - scaledWidth) / 2;\n      const y = (this.__height - scaledHeight) / 2;\n      \n      // Draw the image centered and scaled\n      this.__ctx.drawImage(\n        actualFrame,\n        0, 0, actualFrame.width, actualFrame.height,\n        x, y, scaledWidth, scaledHeight\n      );\n      \n      this.__texture.needsUpdate = true;\n    }\n  },\n\n  /*============================\n  =            ready            =\n  ============================*/\n\n  /**\n   * setup gif animation and play if autoplay is true\n   * @private\n   * @property {string} src - src url\n   * @param {array} times - array of time length of each image\n   * @param {number} cnt - total counts of gif images\n   * @param {array} frames - array of each image\n   */\n  __ready({ src, times, cnt, frames }) {\n    log(\"__ready\");\n    this.__textureSrc = src;\n    this.__delayTimes = times;\n    cnt ? (this.__loopCnt = cnt) : (this.__infinity = true);\n    this.__frames = frames;\n    this.__frameCnt = times.length;\n    this.__startTime = Date.now();\n    \n    // Get the original dimensions\n    const originalWidth = frames[0].width;\n    const originalHeight = frames[0].height;\n    \n    // Calculate dimensions that maintain aspect ratio\n    const maxSize = 2048; // Maximum texture size\n    let width = originalWidth;\n    let height = originalHeight;\n    \n    if (width > maxSize || height > maxSize) {\n      const ratio = Math.min(maxSize / width, maxSize / height);\n      width = Math.floor(width * ratio);\n      height = Math.floor(height * ratio);\n    }\n    \n    // Set dimensions\n    this.__width = width;\n    this.__height = height;\n    this.__cnv.width = width;\n    this.__cnv.height = height;\n    \n    // Configure texture\n    this.__texture.needsPowerOfTwo = false;\n    this.__texture.minFilter = THREE.LinearFilter;\n    this.__texture.magFilter = THREE.LinearFilter;\n    this.__texture.generateMipmaps = false;\n    this.__texture.colorSpace = THREE.SRGBColorSpace;\n    this.__texture.premultiplyAlpha = true;\n    \n    // Reset texture transform\n    this.__texture.repeat.set(1, 1);\n    this.__texture.offset.set(0, 0);\n    \n    this.__draw();\n    if (this.__autoplay) {\n      this.play();\n    } else {\n      this.pause();\n    }\n  },\n\n  /*=============================\n  =            reset            =\n  =============================*/\n  /**\n   * @private\n   */\n  __reset() {\n    this.pause();\n    this.__clearCanvas();\n    this.__startTime = 0;\n    this.__nextFrameTime = 0;\n    this.__frameIdx = 0;\n    this.__frameCnt = 0;\n    this.__delayTimes = null;\n    this.__infinity = false;\n    this.__loopCnt = 0;\n    this.__frames = null;\n    this.__textureSrc = null;\n  },\n});\n"],"names":["exports","gif","successCB","errorCB","pos","delayTimes","loadCnt","graphicControl","imageData","frames","loopCnt","Math","pow","gifHeader","subarray","offset","blockId","label","indexOf","push","frame","disposalMethod","blob","URL","createObjectURL","Blob","length","cnv","document","createElement","imageFix","i","img","Image","onload","e","this","bind","src","toDataURL","width","height","loadImg","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","module","__webpack_modules__","AFRAME","parseUrl","utils","srcLoader","debug","enable","warn","log","gifData","createError","err","status","message","timestamp","Date","now","registerShader","schema","color","type","fog","default","autoplay","init","data","el","components","__cnv","__ctx","getContext","willReadFrequently","__texture","THREE","Texture","minFilter","LinearFilter","magFilter","generateMipmaps","colorSpace","SRGBColorSpace","premultiplyAlpha","repeat","wrapS","RepeatWrapping","wrapT","set","x","y","__material","__reset","material","MeshBasicMaterial","map","transparent","premultipliedAlpha","sceneEl","addBehavior","update","oldData","__updateMaterial","__updateTexture","tick","t","__frames","paused","__startTime","__nextFrameTime","nextFrame","newData","__getMaterialData","Object","keys","forEach","key","Color","__setTexure","__textureSrc","__ready","__autoplay","play","__validateSrc","cb","startsWith","__validateAndGetQuerySelector","error","tagName","toLowerCase","complete","__getImageSrc","addEventListener","baseUrl","baseURI","resolvedUrl","href","srcData","callbacks","tester","onError","errData","crossOrigin","__getUnit8Array","arr","times","cnt","xhr","XMLHttpRequest","open","responseType","uint8Array","Uint8Array","target","response","header","toString","send","selector","querySelector","pause","__paused","togglePlayback","__draw","__delayTimes","__frameIdx","__infinity","__loopCnt","__frameCnt","__clearCanvas","clearRect","__width","__height","needsUpdate","lastFrame","actualFrame","scale","min","scaledWidth","scaledHeight","drawImage","maxSize","ratio","floor","needsPowerOfTwo"],"sourceRoot":""}